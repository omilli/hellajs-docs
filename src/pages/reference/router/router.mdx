---
title: router
description: Set up client-side routing with dynamic parameters, hooks, redirects, and notFound handling.
layout: ../../../layouts/MainLayout.astro
---

# router

Set up client-side routing with dynamic parameters, hooks, redirects, and notFound handling.

## API

```typescript
function router<T>(config: {
  routes: Record<string, RouteValue | string>,
  hash?: boolean,
  hooks?: RouterHooks,
  notFound?: () => void
}): RouteInfo
```
- `routes`: An object where keys are URL patterns and values are handlers, handler objects with hooks, or redirect strings.
- `hooks`: An optional configuration object for global hooks (`before`, `after`), and redirects.
- `notFound`: An optional handler for unmatched routes.
- `hash`: An optional boolean to enable hash-based routing.

## TypeScript

The router is fully typed, providing type inference for route parameters in your handlers.

```typescript
// `params` is automatically typed as { id: string }
router({
  routes: {
    '/users/:id': (params) => {
      console.log(params.id);
    }
  }
});
```

## Basic Usage

Define your application's routes by providing a map of URL patterns to handler functions.

```typescript
import { router } from "@hellajs/router";

router({
  routes: {
    // Static route
    "/": () => renderHomePage(),
    // Dynamic route with a parameter
    "/users/:id": (params) => renderUserProfile(params.id),
    // Wildcard route
    "/files/*": (params) => renderFile(params['*']),
    // Route with query parameters
    "/search": (params, query) => renderSearch(query.q),
  }
});
```

## Key Concepts

### Route Patterns

URL patterns support dynamic parameters (`:id`) and wildcards (`*`) for flexible matching.

```typescript
router({
  routes: {
    '/users/:id': (params) => params.id, // Matches /users/123
    '/files/*': (params) => params['*'], // Matches /files/docs/readme.txt
    '/blog/:category?': (params) => params.category // Optional parameter
  }
});
```

### Navigation Modes

Choose between hash-based routing (`#/path`) or history API routing (`/path`) using the `hash` option.

```typescript
// Hash-based routing: example.com/#/about
router({ routes: { '/about': () => renderAbout() }, hash: true });

// History API routing: example.com/about  
router({ routes: { '/about': () => renderAbout() }, hash: false });
```

### Hook System

Global and per-route hooks provide lifecycle control with `before` and `after` execution points.

```typescript
router({
  routes: {
    '/dashboard': {
      before: () => checkAuth(),
      handler: () => renderDashboard(),
      after: () => trackPageView()
    }
  },
  hooks: { before: () => console.log('Global before') }
});
```

### Route Handlers

Simple functions that receive extracted parameters and query strings for each matched route.

```typescript
router({
  routes: {
    '/search': (params, query) => {
      console.log('Query:', query.q); // ?q=value
      console.log('Sort:', query.sort); // &sort=date
    }
  }
});
```

## Important Considerations

### Route Order

Routes are matched in definition order - place specific routes before generic patterns.

```typescript
// ✅ Specific route first
'/users/admin': () => renderAdmin(),
// ✅ Generic route after
'/users/:id': (params) => renderUser(params.id)
```

### Parameter Types

All route parameters and query values are strings - cast to other types as needed.

```typescript
// ✅ Cast parameters as needed
'/users/:id': (params) => {
  const userId = parseInt(params.id);
  renderUser(userId);
}
```

### Hook Returns

`before` hooks can return `false` to cancel navigation - use for authentication checks.

```typescript
// ✅ Cancel navigation from hooks
'/protected': {
  before: () => isAuthenticated() || navigate('/login'),
  handler: () => renderProtected()
}
```

