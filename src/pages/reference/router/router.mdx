---
title: router
description: Set up client-side routing with dynamic parameters, hooks, redirects, and notFound handling.
layout: ../../../layouts/MainLayout.astro
---

# router

Set up client-side routing with dynamic parameters, hooks, redirects, and notFound handling.

## API

```typescript
function router<T>(config: {
  routes: Record<string, RouteValue | NestedRouteValue | string>,
  hash?: boolean,
  hooks?: RouterHooks,
  redirects?: { from: string[]; to: string }[],
  notFound?: () => void
}): RouteInfo
```
- `routes`: An object where keys are URL patterns and values are handlers, handler objects with hooks, nested route objects with children, or redirect strings.
- `hooks`: An optional configuration object for global hooks (`before`, `after`).
- `redirects`: An optional array of global redirect objects with `from` and `to` properties.
- `notFound`: An optional handler for unmatched routes.
- `hash`: An optional boolean to enable hash-based routing.

## TypeScript

The router is fully typed, providing type inference for route parameters in your handlers.

```typescript
// `params` is automatically typed as { id: string }
router({
  routes: {
    '/users/:id': (params) => {
      console.log(params.id);
    }
  }
});
```

## Basic Usage

Define your application's routes by providing a map of URL patterns to handler functions.

```typescript
import { router } from "@hellajs/router";

router({
  routes: {
    // Static route
    "/": () => renderHomePage(),
    // Dynamic route with a parameter
    "/users/:id": (params) => renderUserProfile(params.id),
    // Wildcard route
    "/files/*": (params) => renderFile(params['*']),
    // Route with query parameters
    "/search": (params, query) => renderSearch(query.q),
  }
});
```

## Key Concepts


### Route Patterns

URL patterns support dynamic parameters (`:id`) and wildcards (`*`) for flexible matching.

```typescript
router({
  routes: {
    '/users/:id': (params) => params.id, // Matches /users/123
    '/files/*': (params) => params['*'], // Matches /files/docs/readme.txt
    '/blog/:category?': (params) => params.category // Optional parameter
  }
});
```


## Nested Routes

Create hierarchical route structures using the `children` property for better organization and automatic parameter inheritance.

```typescript
router({
  routes: {
    "/admin": {
      handler: () => renderAdminDashboard(),
      before: () => requireAuth(),
      children: {
        "/users": {
          handler: () => renderUsersList(),
          children: {
            "/:id": (params) => renderUserDetail(params.id),
            "/:id/edit": (params) => renderUserEdit(params.id)
          }
        },
        "/settings": () => renderAdminSettings()
      }
    }
  }
});

// Routes that will work.
// /admin -> renderAdminDashboard() (with auth check)
// /admin/users -> renderUsersList() (with auth check)  
// /admin/users/123 -> renderUserDetail('123') (with auth check)
// /admin/users/123/edit -> renderUserEdit('123') (with auth check)
// /admin/settings -> renderAdminSettings() (with auth check)
```

### Navigation Modes

Choose between hash-based routing (`#/path`) or history API routing (`/path`) using the `hash` option.

```typescript
// Hash-based routing: example.com/#/about
router({ routes: { '/about': () => renderAbout() }, hash: true });

// History API routing: example.com/about  
router({ routes: { '/about': () => renderAbout() }, hash: false });
```

### Hook System

Global and per-route hooks provide lifecycle control with `before` and `after` execution points.

```typescript
router({
  routes: {
    '/dashboard': {
      before: () => checkAuth(),
      handler: () => renderDashboard(),
      after: () => trackPageView()
    }
  },
  hooks: { before: () => console.log('Global before') }
});
```

### Route Handlers

Simple functions that receive extracted parameters and query strings for each matched route.

```typescript
router({
  routes: {
    '/search': (params, query) => {
      console.log('Query:', query.q); // ?q=value
      console.log('Sort:', query.sort); // &sort=date
    }
  }
});
```

## Important Considerations

### Route Resolution Priority

The router uses intelligent route resolution with the following precedence.

1. **Global redirects** (from `redirects` array)
2. **Route map redirects** (string values in routes)
3. **Nested routes** (prioritized over flat routes)
4. **Flat routes** (traditional route matching)
5. **Not found handler**

Within nested routes, more specific patterns take precedence over wildcards.

```typescript
router({
  routes: {
    "/api": {
      children: {
        "/v1/users": () => renderV1Users(), // More specific
        "/v1/*": () => renderV1Wildcard(),  // Less specific
        "/*": () => renderApiWildcard()     // Least specific
      }
    }
  }
});
```

### Parameter Types

All route parameters and query values are strings - cast to other types as needed.

```typescript
// ✅ Cast parameters as needed
'/users/:id': (params) => {
  const userId = parseInt(params.id);
  renderUser(userId);
}
```

### Hook Returns

`before` hooks execute before route handlers - use for authentication checks and logging.

```typescript
// ✅ Authentication check in hooks
'/protected': {
  before: () => {
    if (!isAuthenticated()) {
      navigate('/login');
    }
  },
  handler: () => renderProtected()
}
```

### Global Redirects

Use the `redirects` array for complex redirect patterns with multiple source paths.

```typescript
router({
  routes: {
    '/dashboard': () => renderDashboard()
  },
  redirects: [
    { from: ['/home', '/start', '/welcome'], to: '/dashboard' },
    { from: ['/profile', '/user'], to: '/dashboard?tab=profile' }
  ]
});
```

