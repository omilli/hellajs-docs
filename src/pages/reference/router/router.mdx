---
title: router
description: Set up client-side routing with dynamic parameters, hooks, redirects, and notFound handling.
layout: ../../../layouts/MainLayout.astro
---

# router

Set up client-side routing with dynamic parameters, hooks, redirects, and notFound handling.

## API

```typescript
function router<T>(config: {
  routes: Record<string, RouteValue | NestedRouteValue | string>,
  hooks?: RouterHooks,
  redirects?: { from: string[]; to: string }[],
  notFound?: () => void
}): RouteInfo
```
- `routes`: An object where keys are URL patterns and values are handlers, handler objects with hooks, nested route objects with children, or redirect strings.
- `hooks`: An optional configuration object for global hooks (`before`, `after`).
- `redirects`: An optional array of global redirect objects with `from` and `to` properties.
- `notFound`: An optional handler for unmatched routes.

## TypeScript

The router is fully typed, providing type inference for route parameters in your handlers.

```typescript
// `params` is automatically typed as { id: string }
// `query` is always provided as second parameter
router({
  routes: {
    '/users/:id': (params, query) => {
      console.log(params.id);
      console.log(query.tab); // Access query parameters
      return { userId: params.id, activeTab: query.tab };
    }
  }
});
```

## Basic Usage

Define your application's routes by providing a map of URL patterns to handler functions.

```typescript
import { router } from "@hellajs/router";
import { signal } from "@hellajs/core";

const currentView = signal('Loading...');
const appData = signal({});

router({
  routes: {
    // Static route
    "/": (params, query) => {
      currentView('HomePage');
      return { page: 'home' };
    },
    // Dynamic route with a parameter
    "/users/:id": (params, query) => {
      currentView(`UserProfile: ${params.id}`);
      return { 
        page: 'userProfile',
        userId: params.id,
        user: loadUser(params.id)
      };
    },
    // Wildcard route
    "/files/*": (params, query) => {
      const filePath = params['*'];
      currentView(`FileViewer: ${filePath}`);
      return {
        page: 'fileViewer',
        filePath,
        content: loadFile(filePath)
      };
    },
    // Route with query parameters
    "/search": (params, query) => {
      currentView(`SearchResults: ${query.q}`);
      return {
        page: 'search',
        term: query.q,
        results: performSearch(query.q)
      };
    }
  }
});
```

## Key Concepts


### Route Patterns

URL patterns support dynamic parameters (`:id`) and wildcards (`*`) for flexible matching.

```typescript
router({
  routes: {
    '/users/:id': (params, query) => {
      // Matches /users/123
      return { userId: params.id, userData: loadUser(params.id) };
    },
    '/files/*': (params, query) => {
      // Matches /files/docs/readme.txt
      // params['*'] = 'docs/readme.txt'
      return { filePath: params['*'], fileContent: loadFile(params['*']) };
    },
    '/blog/:category?': (params, query) => {
      // Optional parameter - category may be undefined
      const category = params.category || 'general';
      return { category, posts: loadPosts(category) };
    }
  }
});
```

## Nested Routes

Create hierarchical route structures using the `children` property for better organization and automatic parameter inheritance.

```typescript
const currentView = signal('Loading...');

router({
  routes: {
    "/admin": {
      handler: (params, query) => {
        currentView('AdminDashboard');
        return { page: 'adminDashboard' };
      },
      before: () => {
        const authResult = requireAuth();
        return { authenticated: authResult };
      },
      children: {
        "/users": {
          handler: (params, query) => {
            currentView('UsersList');
            return { page: 'usersList', users: loadUsers() };
          },
          children: {
            "/:id": (params, query) => {
              currentView(`UserDetail: ${params.id}`);
              return {
                page: 'userDetail',
                userId: params.id,
                user: loadUser(params.id)
              };
            },
            "/:id/edit": (params, query) => {
              currentView(`UserEdit: ${params.id}`);
              return {
                page: 'userEdit',
                userId: params.id,
                user: loadUser(params.id)
              };
            }
          }
        },
        "/settings": (params, query) => {
          currentView('AdminSettings');
          return { page: 'adminSettings', settings: loadSettings() };
        }
      }
    }
  }
});

// Routes that will work.
// /admin -> mount(<AdminDashboard />) (with auth check)
// /admin/users -> mount(<UsersList />) (with auth check)  
// /admin/users/123 -> mount(<UserDetail id="123" />) (with auth check)
// /admin/users/123/edit -> mount(<UserEdit id="123" />) (with auth check)
// /admin/settings -> mount(<AdminSettings />) (with auth check)
```

### Navigation Mode

The router uses the History API for clean URLs (`/path`).

```typescript
// History API routing: example.com/about  
router({ routes: { '/about': () => mount(<AboutPage />) } });
```

### Hook System

Global and per-route hooks provide lifecycle control with `before` and `after` execution points.

```typescript
const currentView = signal('Loading...');

router({
  routes: {
    '/dashboard': {
      before: () => {
        const authResult = checkAuth();
        return { authCheck: authResult };
      },
      handler: (params, query) => {
        currentView('Dashboard');
        return { page: 'dashboard', data: loadDashboardData() };
      },
      after: () => {
        trackPageView('dashboard');
        return { tracked: true };
      }
    }
  },
  hooks: { 
    before: () => {
      console.log('Global before');
      return { globalBefore: true };
    }
  }
});
```

### Route Handlers

Simple functions that receive extracted parameters and query strings for each matched route.

```typescript
router({
  routes: {
    '/search': (params, query) => {
      console.log('Query:', query.q); // ?q=value
      console.log('Sort:', query.sort); // &sort=date
      
      const searchResults = performSearch({
        term: query.q,
        sort: query.sort || 'relevance',
        page: parseInt(query.page || '1')
      });
      
      return {
        page: 'search',
        searchTerm: query.q,
        sortBy: query.sort,
        results: searchResults
      };
    }
  }
});
```

## Important Considerations

### Route Resolution Priority

The router uses intelligent route resolution with the following precedence.

1. **Global redirects** (from `redirects` array)
2. **Route map redirects** (string values in routes)
3. **Nested routes** (prioritized over flat routes)
4. **Flat routes** (traditional route matching)
5. **Not found handler**

Within nested routes, more specific patterns take precedence over wildcards.

```typescript
const currentView = signal('Loading...');

router({
  routes: {
    "/api": {
      children: {
        "/v1/users": (params, query) => {
          // More specific - matches first
          currentView('V1Users');
          return { api: 'v1', endpoint: 'users', data: getV1Users() };
        },
        "/v1/*": (params, query) => {
          // Less specific - matches /v1/anything-else
          currentView(`V1Wildcard: ${params['*']}`);
          return { api: 'v1', endpoint: params['*'] };
        },
        "/*": (params, query) => {
          // Least specific - matches /api/anything
          currentView(`ApiWildcard: ${params['*']}`);
          return { api: 'generic', endpoint: params['*'] };
        }
      }
    }
  }
});
```

### Parameter Types

All route parameters and query values are strings - cast to other types as needed.

```typescript
// ✅ Cast parameters as needed
// Always include query parameter in handler signature
'/users/:id': (params, query) => {
  const userId = parseInt(params.id);
  const userData = loadUser(userId);
  return {
    page: 'userDetail',
    userId,
    user: userData,
    activeTab: query.tab || 'overview'
  };
}
```

### Hook Returns

`before` hooks execute before route handlers - use for authentication checks and logging.

```typescript
// ✅ Authentication check in hooks
// Hooks should return values for data flow
'/protected': {
  before: () => {
    if (!isAuthenticated()) {
      navigate('/login');
      return { authenticated: false, redirected: true };
    }
    return { authenticated: true };
  },
  handler: (params, query) => {
    currentView('ProtectedPage');
    return {
      page: 'protected',
      user: getCurrentUser(),
      permissions: getUserPermissions()
    };
  }
}
```

### Global Redirects

Use the `redirects` array for complex redirect patterns with multiple source paths.

```typescript
const currentView = signal('Loading...');

router({
  routes: {
    '/dashboard': (params, query) => {
      currentView('Dashboard');
      const activeTab = query.tab || 'overview';
      return {
        page: 'dashboard',
        activeTab,
        data: loadDashboardData(activeTab)
      };
    }
  },
  redirects: [
    { from: ['/home', '/start', '/welcome'], to: '/dashboard' },
    { from: ['/profile', '/user'], to: '/dashboard?tab=profile' }
  ]
});
```

