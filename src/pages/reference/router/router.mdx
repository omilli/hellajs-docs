---
title: router
description: Set up client-side routing with dynamic parameters, hooks, redirects, and notFound handling.
layout: ../../../layouts/MainLayout.astro
---

# router

Set up client-side routing with dynamic parameters, hooks, redirects, and notFound handling.

## API

```typescript
function router<T>(config: {
  routes: Record<string, RouteValue | NestedRouteValue | string>,
  hash?: boolean,
  hooks?: RouterHooks,
  redirects?: { from: string[]; to: string }[],
  notFound?: () => void
}): RouteInfo
```
- `routes`: An object where keys are URL patterns and values are handlers, handler objects with hooks, nested route objects with children, or redirect strings.
- `hooks`: An optional configuration object for global hooks (`before`, `after`).
- `redirects`: An optional array of global redirect objects with `from` and `to` properties.
- `notFound`: An optional handler for unmatched routes.
- `hash`: An optional boolean to enable hash-based routing.

## TypeScript

The router is fully typed, providing type inference for route parameters in your handlers.

```typescript
// `params` is automatically typed as { id: string }
router({
  routes: {
    '/users/:id': (params) => {
      console.log(params.id);
    }
  }
});
```

## Basic Usage

Define your application's routes by providing a map of URL patterns to handler functions.

```typescript
import { mount } from '@hellajs/dom';
import { router } from "@hellajs/router";

mount(<>Loading...</>);

router({
  routes: {
    // Static route
    "/": () => mount(<HomePage />),
    // Dynamic route with a parameter
    "/users/:id": (params) => mount(<UserProfile id={params.id} />),
    // Wildcard route
    "/files/*": (params) => mount(<FileViewer path={params['*']} />),
    // Route with query parameters
    "/search": (params, query) => mount(<SearchResults term={query.q} />),
  }
});
```

## Key Concepts


### Route Patterns

URL patterns support dynamic parameters (`:id`) and wildcards (`*`) for flexible matching.

```typescript
router({
  routes: {
    '/users/:id': (params) => params.id, // Matches /users/123
    '/files/*': (params) => params['*'], // Matches /files/docs/readme.txt
    '/blog/:category?': (params) => params.category // Optional parameter
  }
});
```


## Nested Routes

Create hierarchical route structures using the `children` property for better organization and automatic parameter inheritance.

```typescript
router({
  routes: {
    "/admin": {
      handler: () => mount(<AdminDashboard />),
      before: () => requireAuth(),
      children: {
        "/users": {
          handler: () => mount(<UsersList />),
          children: {
            "/:id": (params) => mount(<UserDetail id={params.id} />),
            "/:id/edit": (params) => mount(<UserEdit id={params.id} />)
          }
        },
        "/settings": () => mount(<AdminSettings />)
      }
    }
  }
});

// Routes that will work.
// /admin -> mount(<AdminDashboard />) (with auth check)
// /admin/users -> mount(<UsersList />) (with auth check)  
// /admin/users/123 -> mount(<UserDetail id="123" />) (with auth check)
// /admin/users/123/edit -> mount(<UserEdit id="123" />) (with auth check)
// /admin/settings -> mount(<AdminSettings />) (with auth check)
```

### Navigation Modes

Choose between hash-based routing (`#/path`) or history API routing (`/path`) using the `hash` option.

```typescript
// Hash-based routing: example.com/#/about
router({ routes: { '/about': () => mount(<AboutPage />) }, hash: true });

// History API routing: example.com/about  
router({ routes: { '/about': () => mount(<AboutPage />) }, hash: false });
```

### Hook System

Global and per-route hooks provide lifecycle control with `before` and `after` execution points.

```typescript
router({
  routes: {
    '/dashboard': {
      before: () => checkAuth(),
      handler: () => mount(<Dashboard />),
      after: () => trackPageView()
    }
  },
  hooks: { before: () => console.log('Global before') }
});
```

### Route Handlers

Simple functions that receive extracted parameters and query strings for each matched route.

```typescript
router({
  routes: {
    '/search': (params, query) => {
      console.log('Query:', query.q); // ?q=value
      console.log('Sort:', query.sort); // &sort=date
    }
  }
});
```

## Important Considerations

### Route Resolution Priority

The router uses intelligent route resolution with the following precedence.

1. **Global redirects** (from `redirects` array)
2. **Route map redirects** (string values in routes)
3. **Nested routes** (prioritized over flat routes)
4. **Flat routes** (traditional route matching)
5. **Not found handler**

Within nested routes, more specific patterns take precedence over wildcards.

```typescript
router({
  routes: {
    "/api": {
      children: {
        "/v1/users": () => mount(<V1Users />), // More specific
        "/v1/*": () => mount(<V1Wildcard />),  // Less specific
        "/*": () => mount(<ApiWildcard />)     // Least specific
      }
    }
  }
});
```

### Parameter Types

All route parameters and query values are strings - cast to other types as needed.

```typescript
// ✅ Cast parameters as needed
'/users/:id': (params) => {
  const userId = parseInt(params.id);
  mount(<UserDetail id={userId} />);
}
```

### Hook Returns

`before` hooks execute before route handlers - use for authentication checks and logging.

```typescript
// ✅ Authentication check in hooks
'/protected': {
  before: () => {
    if (!isAuthenticated()) {
      navigate('/login');
    }
  },
  handler: () => mount(<ProtectedPage />)
}
```

### Global Redirects

Use the `redirects` array for complex redirect patterns with multiple source paths.

```typescript
router({
  routes: {
    '/dashboard': () => mount(<Dashboard />)
  },
  redirects: [
    { from: ['/home', '/start', '/welcome'], to: '/dashboard' },
    { from: ['/profile', '/user'], to: '/dashboard?tab=profile' }
  ]
});
```

