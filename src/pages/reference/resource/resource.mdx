---
title: resource
description: Reactive async data fetching with caching, abort, and mutation.
layout: ../../../layouts/MainLayout.astro
---

# resource

Reactive async data fetching with caching, abort, and mutation.

## API

```typescript
// Overload for simple URL fetching
function resource<T>(url: string, options?: ResourceOptions<T, string>): Resource<T>;

// Overload for custom fetcher functions
function resource<T, K>(fetcher: (key: K) => Promise<T>, options?: ResourceOptions<T, K>): Resource<T>;

// The returned resource object
interface Resource<T> {
  data: ReadonlySignal<T | undefined>;
  error: ReadonlySignal<unknown>;
  loading: ReadonlySignal<boolean>;
  status: ReadonlySignal<"idle" | "loading" | "success" | "error">;
  fetch(): void;
  request(): void;
  abort(): void;
  invalidate(): void;
}
```

## TypeScript

The `resource` function is generic and infers the data type from the fetcher's return promise.

```typescript
interface User { id: number; name: string; }

// T is inferred as User[]
const usersResource = resource(() => 
  fetch('/api/users').then(res => res.json() as Promise<User[]>)
);
```

## Basic Usage

A resource does **not** fetch data on creation. You must call `.fetch()` or `.request()` to initiate the data loading process.

```typescript
import { resource } from '@hellajs/resource';
import { effect } from '@hellajs/core';

// 1. Create the resource
const usersResource = resource<User[]>(() => 
  fetch('https://api.example.com/users').then(r => r.json())
);

// 2. Use its reactive state
effect(() => {
  console.log(`Status: ${usersResource.status()}`);
  if (usersResource.data()) {
    console.log('Users:', usersResource.data().length);
  }
});

// 3. Start fetching
usersResource.fetch();
```

## Key Concepts

### Fetch Control
- `.fetch()`: Fetches data, using a cached value if available and not expired.
- `.request()`: Forces a new fetch, ignoring the cache.
- `.invalidate()`: Clears the cache for the current key and triggers a `.request()`.
- `.abort()`: Cancels any ongoing request and resets state.

### Reactive Keys
The `key` option makes a resource dynamic. The resource will fetch data based on the value returned by the `key` function. This is the primary way to create resources that depend on other reactive state.

```typescript
const userId = signal(1);

const userResource = resource(
  (id) => fetch(`/api/users/${id}`).then(r => r.json()),
  { key: () => userId() } // Depends on the userId signal
);

// Fetch user 1
userResource.fetch();

// To fetch a different user, change the key and call fetch again
userId(2);
userResource.fetch();
```

### Caching
Set `cacheTime` (in milliseconds) to enable caching. Each unique key gets its own cache entry.

```typescript
const postsResource = resource(
  (id) => fetch(`/api/posts/${id}`).then(r => r.json()),
  { 
    key: () => postId(),
    cacheTime: 60000 // Cache for 1 minute
  }
);
```

### Data Mutations
To update data after a mutation (e.g., a POST or PUT request), perform the mutation and then call `.invalidate()` on the relevant resource to refetch the fresh data.

```typescript
async function updateUser(data) {
  await fetch(`/api/users/${userId()}`, { method: 'PUT', body: JSON.stringify(data) });
  
  // Invalidate the user resource to get the updated data
  userResource.invalidate();
}
```

## Important Considerations

### Manual Fetching

Resources don't auto-fetch on creation - you must explicitly call `.fetch()` or `.request()`.

```typescript
// ❌ No data fetched yet
const userResource = resource(() => fetch('/api/user'));
console.log(userResource.data()); // undefined
// ✅ Explicitly fetch data
userResource.fetch();
```

### Memory Management

Each unique key creates a separate cache entry - consider key design for large datasets.

```typescript
// ❌ Too many cache entries
{ key: () => Math.random() }
// ✅ Stable, meaningful keys
{ key: () => `user-${userId()}` }
```

### Error Handling

Always check both `error()` and `status()` states for proper error handling.

```typescript
// ✅ Proper error handling
effect(() => {
  if (resource.error()) {
    console.error('Failed:', resource.error());
  }
  if (resource.status() === 'success') {
    console.log('Data:', resource.data());
  }
});
```

