---
title: resource
description: Reactive async data fetching with caching, abort, and mutation.
layout: ../../../layouts/MainLayout.astro
---

# resource

Reactive async data fetching with caching, abort, and mutation.

## API

```typescript
// Overload for simple URL fetching
function resource<T>(url: string, options?: ResourceOptions<T, string>): Resource<T>;

// Overload for custom fetcher functions
function resource<T, K>(fetcher: (key: K) => Promise<T>, options?: ResourceOptions<T, K>): Resource<T>;

// The returned resource object
interface Resource<T> {
  data: ReadonlySignal<T | undefined>;
  error: ReadonlySignal<ResourceError | undefined>;
  loading: ReadonlySignal<boolean>;
  status: ReadonlySignal<ResourceStatus>;
  /** @deprecated Use get() instead */
  fetch(): void;
  get(): void;
  request(): void;
  abort(): void;
  invalidate(): void;
  setData: (updater: T | ((old: T | undefined) => T)) => void;
  cacheKey: () => unknown;
  mutate: <TVariables = any>(variables: TVariables) => Promise<T>;
  reset(): void;
}

type ResourceStatus = "idle" | "loading" | "success" | "error";

type ResourceErrorCategory = 
  | 'network' | 'validation' | 'authorization' | 'not_found' 
  | 'server' | 'client' | 'timeout' | 'abort' | 'unknown';

interface ResourceError {
  message: string;
  category: ResourceErrorCategory;
  statusCode?: number;
  originalError?: unknown;
}

interface ResourceOptions<T, K> {
  key?: () => K;
  enabled?: boolean;
  initialData?: T;
  cacheTime?: number;
  timeout?: number;
  abortSignal?: AbortSignal;
  deduplicate?: boolean;
  onSuccess?: (data: T) => void;
  onError?: (err: unknown) => void;
  onMutate?: <TVariables, TContext = unknown>(variables: TVariables) => Promise<TContext> | TContext;
  onSettled?: <TVariables, TContext = unknown>(data?: T, error?: unknown, variables?: TVariables, context?: TContext) => Promise<void> | void;
}
```

## TypeScript

The `resource` function is generic and infers the data type from the fetcher's return promise.

```typescript
interface User { id: number; name: string; }

// T is inferred as User[]
const usersResource = resource(() => 
  fetch('/api/users').then(res => res.json() as Promise<User[]>)
);
```

## Basic Usage

A resource does **not** fetch data on creation. You must call `.get()` or `.request()` to initiate the data loading process.

```typescript
import { resource } from '@hellajs/resource';
import { effect } from '@hellajs/core';

// 1. Create the resource
const usersResource = resource<User[]>(() => 
  fetch('https://api.example.com/users').then(r => r.json())
);

// 2. Use its reactive state
effect(() => {
  console.log(`Status: ${usersResource.status()}`);
  if (usersResource.data()) {
    console.log('Users:', usersResource.data().length);
  }
});

// 3. Start fetching
usersResource.get();
```

## Key Concepts

### Control Methods

- `.get()`: Cache-first fetch (uses cached data if valid and not expired)
- `.fetch()`: **Deprecated** - Use `.get()` instead
- `.request()`: Forces a new fetch, ignoring cache completely  
- `.abort()`: Cancels ongoing request and resets to initial state
- `.invalidate()`: Clears cache entry and triggers fresh `.request()`
- `.setData(updater)`: Manually update cached data with value or function
- `.reset()`: Reset resource to initial state (clears data, error, loading)
- `.mutate(variables)`: Execute mutation with given variables
- `.cacheKey()`: Get current cache key for debugging

### Reactive Keys
The `key` option makes a resource dynamic. The resource will fetch data based on the value returned by the `key` function. This is the primary way to create resources that depend on other reactive state.

```typescript
const userId = signal(1);

const userResource = resource(
  (id) => fetch(`/api/users/${id}`).then(r => r.json()),
  { key: () => userId() } // Depends on the userId signal
);

// Fetch user 1
userResource.get();

// To fetch a different user, change the key and call get again
userId(2);
userResource.get();
```

### Caching
Set `cacheTime` (in milliseconds) to enable caching. Each unique key gets its own cache entry.

```typescript
const postsResource = resource(
  (id) => fetch(`/api/posts/${id}`).then(r => r.json()),
  { 
    key: () => postId(),
    cacheTime: 60000 // Cache for 1 minute
  }
);
```

### Data Mutations
To update data after a mutation (e.g., a POST or PUT request), perform the mutation and then call `.invalidate()` on the relevant resource to refetch the fresh data.

```typescript
async function updateUser(data) {
  await fetch(`/api/users/${userId()}`, { method: 'PUT', body: JSON.stringify(data) });
  
  // Invalidate the user resource to get the updated data
  userResource.invalidate();
}
```

## Important Considerations

### Manual Fetching

Resources don't auto-fetch on creation - you must explicitly call `.get()` or `.request()`.

```typescript
// ❌ No data fetched yet
const userResource = resource(() => fetch('/api/user'));
console.log(userResource.data()); // undefined
// ✅ Explicitly fetch data
userResource.get();
```

### Memory Management

Each unique key creates a separate cache entry - consider key design for large datasets.

```typescript
// ❌ Too many cache entries
{ key: () => Math.random() }
// ✅ Stable, meaningful keys
{ key: () => `user-${userId()}` }
```

### Error Handling

Always check both `error()` and `status()` states for proper error handling.

```typescript
// ✅ Proper error handling
effect(() => {
  if (resource.error()) {
    console.error('Failed:', resource.error());
  }
  if (resource.status() === 'success') {
    console.log('Data:', resource.data());
  }
});
```

