---
layout: ../../../layouts/MainLayout.astro
title: Templates
description: JSX templating with reactive bindings and control flow patterns.
---

import { Icon } from "astro-icon/components";

# Granular Templates

An approach that binds reactive values directly to DOM elements, enabling surgical updates when state changes.

Templating in [JSX](/plugins) is familiar, with a few small differences. 

## Reactive Bindings

Behind the scenes, function references are used to create reactive bindings between signals and DOM elements.

[JSX](/plugins) abstracts the creation of function references, allowing you to optionally omit arrow functions.

### Valid Binding Syntax

✅ Arrow event: `onClick={() => console.log(1)}`

✅ Arrowless event: `onClick={console.log(1)}`

✅ Reference binding: `<h1>{count}</h1>`

✅ Value binding: `<h1>{count()}</h1>`

✅ Derived function: `<h2>{() => count() * 2}</h2>`

✅ Derived expression: `<h2>{count() * 2}</h2>`

**Beware of template literals. You must call the signal.**

✅ Reactive literal: ```<h1>{`Count: ${count()}`}</h1>```

⛔ Static literal: ```<h1>{`Count: ${count}`}</h1>```

### Derived Functions

Create derived functions inside components or use [`computed`](/reference/core/computed) to memoize the return value.

```jsx
const TodoStats = () => {
  const todos = signal([
    { id: 1, text: 'Learn HellaJS', done: false },
    { id: 2, text: 'Build an app', done: true }
  ]);

  // Memoized function
  const completedTodos = computed(() => todos().filter(t => t.done));

  // Derived function
  const completedTotal = () => completedTodos().length;
  const remainingTotal = () => todo().length() - completedTodosTotal();

  return (
    <div>
      <p>Completed: {completedTotal}</p>
      <p>Remaining: {remainingTotal}</p>
    </div>
  );
};
```

**When to use each approach:**

- Use derived functions for fimple transformations, filtering, mapping, etc.
- Use [computed](/reference/core/computed) for values that will benefit from memoization


### Inline Reactivity

When any function call is present in an expression it automatically becomes reactive.

```jsx
const Counter = () => {
  const count = signal(0);

  return (
    <div>
      <h1>Count: {count}</h1>
      <p>Double {count() * 2}</p>
      <p>{count() % 2 === 0 ? "Even" : "Odd"}</p>
      <button onClick={() => console.log(count())}>
        Log Count
      </button>
    </div>
  );
};
```

## Components

Simple functions that return JSX elements (and transform to [HellaNodes](/learn/concepts/templates#internal-mechanics)). Supports reactive data flow through [signal](/reference/core/signal) props.

### Static Components

Static components render fixed elements that dont change over time.

```jsx
const Header = () => <header>HellaJS</header>;
const Footer = () => <footer>Hella Fast, Hella Small, Hella Simple</footer>;
```

### Interactive Components

Interactive components create reactive bindings during their execution, automatically handling updates.

```jsx
const Counter = ({ initialValue = 0 }) => {
  const count = signal(initialValue);
  
  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={() => count(count() + 1)}>
        Increment
      </button>
      <button onClick={() => count(count() - 1)}>
        Decrement
      </button>
    </div>
  );
};
```

### Component Composition

Compose naturally through props and children. Since components are just functions, composition is straightforward..

```jsx
const Card = ({ title, variant = 'default' }, children) => (
  <div class={`card card-${variant}`}>
    <div class="card-header"><h2>{title}</h2></div>
    <div class="card-content">{children}</div>
  </div>
);

const Button = ({ variant = 'primary', onClick, children }) => (
  <button class={`btn btn-${variant}`} onClick={() => onClick}>
    {children}
  </button>
);

// Components compose naturally
const MyPage = () => (
  <Card title="Welcome" variant="highlighted">
    <p>Welcome to our application!</p>
    <Button onClick={() => alert('Hello!')}>Get Started</Button>
  </Card>
);
```

### Reactive Data Flow

Pass reactive signals between components, they maintain their reactivity across component boundaries.

```jsx
const TodoCard = ({ todo }) => (
  <div class="todo-card">
    <h3>{todo().text}</h3>
    <p>Priority: {todo().priority}</p>
    <span class={`status ${todo().done ? 'completed' : 'pending'}`}>
      {todo().done ? 'Completed' : 'Pending'}
    </span>
  </div>
);

const TodoApp = () => {
  const selectedTodo = signal({ 
    id: 1,
    text: 'Learn HellaJS', 
    priority: 'high',
    done: false
  });
  
  return (
    <div class="todo-app">
      <TodoCard todo={selectedTodo} />
      <button onClick={() => selectedTodo({
        id: 2,
        text: 'Build awesome app',
        priority: 'medium', 
        done: true
      })}>
        Switch Todo
      </button>
    </div>
  );
};
```

## Control Flow

### Conditional Rendering

Familiar JSX conditional rendering.

```jsx
const Counter = () => {
  const count = signal(0);

  return (
    <div>
      <h1>Count: {count}</h1>
      <h2>Doubled: {count() * 2}</h2>
      <p>Count is: {count() % 2 === 0 ? 'even' : 'odd'}</p>
      {count() > 5 && <p>Great job! Count is greater than 5!</p>}
      <button onClick={() => count(count() + 1)}>
        Increment
      </button>
    </div>
  );
};
```

### Lists and Iteration

Create static lists using regular array methods for one-time rendering, or reactive lists using the optimized [forEach](/reference/dom/foreach) function.

✅ Reactive: ` <ul>{forEach(todos, todo => <li>{todo.text}</li>)}</ul>`

⛔ Static: `  <ul>{todos().map(todo => <li>{todo.text}</li>)}</ul>`

```jsx
const TodoList = () => {
  const todos = signal([
    { id: 1, text: 'Learn HellaJS', done: false },
    { id: 2, text: 'Build an app', done: false }
  ]);
  
  const addTodo = (text) => {
    todos([...todos(), { 
      id: Date.now(), 
      text, 
      done: false 
    }]);
  };
  
  return (
    <div>
      <ul>
        {forEach(todos, todo => (
          <li key={todo.id} class={todo.done ? 'done' : ''}>
            <input 
              type="checkbox" 
              checked={todo.done}
              onChange={e => {
                const updated = todos().map(t => 
                  t.id === todo.id ? { ...t, done: e.target.checked } : t
                );
                todos(updated);
              }}
            />
            {todo.text}
          </li>
        ))}
      </ul>
    </div>
  );
};
```

### Fragments and Children

Group elements without a wrapper element. Great for when a component's structure doesn't align with semantic HTML.

```jsx
const Modal = ({ isOpen, onClose, children }) => {
  return (
    <>
      {isOpen() && (
        <>
          <div class="overlay" onClick={onClose} />
          <div class="modal">
            <button class="close" onClick={onClose}>×</button>
            {children}
          </div>
        </>
      )}
    </>
  );
};

const App = () => {
  const showModal = signal(false);
  
  return (
    <div>
      <button onClick={() => showModal(true)}>Open Modal</button>
      
      <Modal isOpen={showModal} onClose={showModal(false)}>
        <h2>Modal Content</h2>
        <p>This is inside the modal!</p>
      </Modal>
    </div>
  );
};
```

## Element Lifecycle

<div role="alert" class="alert alert-error text-base">
  <Icon name="ph:warning" width={24} height={24} />
  <span>Unlike other frameworks, lifecycle hooks are tied directly to elements, not component scope.</span>
</div>

### `onUpdate`

Executes whenever a reactive binding updates an element's properties, attributes, or content.

### `onDestroy`

Executes when an element is removed from the DOM, providing an opportunity to perform cleanup tasks.

```jsx
const Counter = () => {
  const count = signal(0);
  
  return (
    <div onDestroy={console.log('Counter component destroyed')}>
      <h1 onUpdate={console.log('Count updated to:', count())}>{count}</h1>
      <button onClick={() => count(count() + 1)}>
        Increment
      </button>
    </div>
  );
};
```

## Optimization Strategies

### Untracked Reads

Use [untracked](/reference/core/untracked) to read [signals](/reference/core/signal) without creating dependencies.

```jsx
const Counter = () => {
  const count = signal(0);
  const debugMode = signal(true);
  
  const doubled = () => {
    const value = count();
    
    // Read debugMode without making it a dependency
    if (untracked(() => debugMode())) {
      console.log('Debug: count is', value);
    }
    
    return value * 2;
  };
  
  return (
    <div>
      <h1>Count: {count}</h1>
      <h2>Doubled: {doubled}</h2>
      <button onClick={() => count(count() + 1)}>Increment</button>
      <button onClick={() => debugMode(!debugMode())}>
        Toggle Debug: {debugMode() ? 'On' : 'Off'}
      </button>
    </div>
  );
};
```

### Cleanup With `onDestroy`

Use `onDestroy` on the root element to cleanup when the component is removed from the DOM.

```jsx
const Counter = () => {
  const count = signal(0);
  
  const interval = setInterval(() => {
    count(count() + 1);
  }, 1000);

  return (
    <div onDestroy={clearInterval(interval)}>
      <h1>{count}</h1>
    </div>
  );
};
```

## Internal Mechanics

A sophisticated yet lightweight approach to binding reactive data directly to DOM elements.

#### HellaNode Architecture

Every template element is represented as a **HellaNode** (Virtual Node) object containing three core properties.
- **tag** - The HTML element name or fragment identifier
- **props** - Element attributes, properties, and lifecycle hooks  
- **children** - Array of child HellaNodes or primitive values

```
HellaNode {
  tag: "div",
  props: { class: () => count() > 5 ? "active" : "" },
  children: [count, "items"]
}
```

Unlike virtual DOM systems that diff entire trees, HellaNodes serve as templates, establishing reactive connections during render.

#### HellaNode Templating

For scenarios where JSX isn't available or when programmatically generating templates, you can construct HellaNodes directly.


<div role="alert" class="alert alert-error text-base">
  <Icon name="ph:warning" width={24} height={24} />
  <span>If you use HellaNodes, you need to create function references manually</span>
</div>

✅ Reactive: `children: count`

✅ Reactive: `children: () => count() * 2`

✅ Reactive: `children: () => count() % 2 === 0 ? "Even" : "Odd"`

✅ Good: `onClick: () => console.log(1)`

⛔ Static: `children: () => count`

⛔ Static: `children: () => count`

⛔ Static: `children: count() % 2 === 0 ? "Even" : "Odd"`

⛔ Bad: `onClick: console.log(1)`


```js
const Counter = () => {
  const count = signal(0);

  return {
    tag: 'div',
    children: [
      {
        tag: 'h1',
        children: count  // Function reference for reactivity
      },
      {
        tag: 'button',
        props: { onClick: () => count(count() + 1) },
        children: 'Increment'
      }
    ]
  };
};
```

#### Reactive Binding Process

When mounting a template, the system distinguishes between static values and function references to establish reactive bindings.

1. **Function Detection** - The mount system identifies function references in props and children
2. **Effect Creation** - Each reactive binding creates a dedicated effect using the core reactivity system
3. **Direct DOM Binding** - Effects update specific DOM properties without intermediate virtual representations
4. **Lifecycle Integration** - Element lifecycle hooks are wired directly to DOM mutation events

```
Signal Change → Effect Execution → Direct DOM Update
     ↑                                      ↓
     └── No Virtual DOM Diffing ←──────────┘
```

#### Dynamic Content Handling

Dynamic children (conditional renders and function expressions) use a sophisticated comment-marker system for efficient DOM updates.

- **Boundary Markers** - HTML comments mark the start and end of dynamic content regions
- **Content Replacement** - When expressions change, only content between markers is replaced
- **Fragment Support** - Multiple elements can be inserted or removed as cohesive units
- **Cleanup Coordination** - Removed elements trigger automatic effect cleanup and lifecycle hooks

#### List Optimization

The `forEach` helper implements advanced list diffing using the Longest Increasing Subsequence (LIS) algorithm.

- **Key-Based Tracking** - Items are tracked by unique keys for efficient reordering
- **Minimal DOM Operations** - Only elements that actually need moving are repositioned
- **Memory Efficiency** - Node references are cached and reused across updates
- **Performance Scaling** - Algorithms ensure performance remains optimal even with large lists

#### Element Lifecycle Management

Element lifecycle is managed through a combination of direct hooks and automatic observation.

- **MutationObserver Integration** - A global observer watches for DOM removals
- **Effect Registration** - Each element maintains a set of cleanup functions for its reactive bindings
- **Automatic Cleanup** - When elements are removed, all associated effects are disposed automatically
- **Memory Safety** - Circular references are prevented through proper cleanup sequencing

#### Rendering Pipeline

The complete rendering process follows this optimized pipeline.

1. **HellaNode Resolution** - Templates are converted to HellaNode objects
2. **Element Creation** - Real DOM elements are created for each HellaNode
3. **Property Binding** - Static properties are set directly, reactive properties create effects
4. **Child Mounting** - Child elements are recursively processed and appended
5. **Effect Activation** - All reactive bindings begin tracking their dependencies
6. **Lifecycle Registration** - Elements are registered for automatic cleanup on removal
