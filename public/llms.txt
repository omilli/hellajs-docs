# HellaJS - Comprehensive API Reference for MCP Servers

HellaJS is a modern, reactive JavaScript framework that provides fine-grained reactivity, efficient DOM manipulation, and comprehensive state management. This document serves as a complete API reference for MCP servers working with HellaJS applications.

## Framework Overview & Philosophy

### Core Principles
- **Fine-grained Reactivity**: Automatic dependency tracking with minimal overhead
- **Test-driven Development**: Comprehensive test coverage for all APIs
- **TypeScript-first**: Full type safety with intelligent inference
- **Framework Agnostic**: Works with any build system or runtime
- **Performance Oriented**: Optimized for modern JavaScript engines

### Architecture
HellaJS consists of six core packages that work together:
- `@hellajs/core` - Reactive primitives (signals, effects, computed)
- `@hellajs/dom` - DOM manipulation and JSX rendering
- `@hellajs/css` - CSS-in-JS styling system
- `@hellajs/resource` - Data fetching and caching
- `@hellajs/router` - Client-side routing
- `@hellajs/store` - Reactive state management

---

## Core Reactivity (@hellajs/core)

The core package provides the fundamental reactive primitives that power the entire framework.

### Signals - Reactive State

Signals are the foundation of HellaJS reactivity. They hold values and notify dependents when changed.

```typescript
import { signal } from '@hellajs/core';

// Basic signal creation and usage
const count = signal(0);
console.log(count()); // 0

// Updating signals
count(5);
console.log(count()); // 5

// TypeScript inference
const name = signal<string | undefined>();
const user = signal({ id: 1, name: 'Alice' });
const items = signal([1, 2, 3]);
```

#### Deep Equality Optimization

Signals use deep equality comparison for objects and arrays, preventing unnecessary updates:

```typescript
const todos = signal([
  { id: 1, text: 'Learn HellaJS', done: false }
]);

// L Mutation doesn't trigger reactivity
todos().push({ id: 2, text: 'New todo', done: false }); // No update

//  Setting new arrays triggers updates when content differs
todos([
  { id: 1, text: 'Learn HellaJS', done: true } // Changed done to true
]); // Triggers update

//  Setting identical content doesn't trigger unnecessary updates
todos([
  { id: 1, text: 'Learn HellaJS', done: true } // Same as before
]); // No update - content identical
```

### Computed - Derived Values

Computed signals derive their values from other signals automatically:

```typescript
import { signal, computed } from '@hellajs/core';

const count = signal(0);
const doubled = computed(() => count() * 2);

console.log(doubled()); // 0
count(5);
console.log(doubled()); // 10

// Complex computed values with multiple dependencies
const firstName = signal('John');
const lastName = signal('Doe');
const fullName = computed(() => `${firstName()} ${lastName()}`);

// Conditional dependencies - only tracks relevant signals
const view = signal('counter');
const todos = signal([]);
const currentTitle = computed(() => {
  const currentView = view();
  if (currentView === 'counter') {
    return `Count: ${count()}`; // Only tracks count
  } else {
    return `Todos: ${todos().length}`; // Only tracks todos
  }
});
```

### Effects - Reactive Side Effects

Effects run when their reactive dependencies change:

```typescript
import { signal, effect } from '@hellajs/core';

const count = signal(0);

// Basic effect
const cleanup = effect(() => {
  console.log(`Count is: ${count()}`);
});

count(5); // Logs: "Count is: 5"

// Effect cleanup
cleanup(); // Stops tracking count changes

// Async operations in effects
const userId = signal(1);
const userDetails = signal(null);
const loading = signal(false);

effect(() => {
  const id = userId();
  loading(true);
  
  fetch(`/api/users/${id}`)
    .then(response => response.json())
    .then(user => {
      userDetails(user);
      loading(false);
    })
    .catch(error => {
      console.error('Failed to load user:', error);
      userDetails(null);
      loading(false);
    });
});
```

### Batching Updates

Group multiple signal updates into a single execution cycle:

```typescript
import { signal, computed, effect, batch } from '@hellajs/core';

const count = signal(0);
const multiplier = signal(1);
const result = computed(() => count() * multiplier());

effect(() => {
  console.log(`Result: ${result()}`);
});

// Without batching - result computes twice
count(5);        // Logs: "Result: 5"
multiplier(2);   // Logs: "Result: 10"

// With batching - result computes once
batch(() => {
  count(10);     // No effect execution yet
  multiplier(3); // No effect execution yet
});              // Logs: "Result: 30"
```

### Untracked Reads

Read signals without creating dependencies:

```typescript
import { signal, computed, untracked } from '@hellajs/core';

const count = signal(0);
const multiplier = signal(10);

// With untracked - only recomputes when count changes
const result = computed(() => {
  return count() * untracked(() => multiplier()); // Only depends on count
});

count(5);      // result recalculates
multiplier(20); // result does NOT recalculate
```

### Manual Effect Flushing

For advanced use cases, manually flush pending effects:

```typescript
import { signal, effect, flush } from '@hellajs/core';

const count = signal(0);
effect(() => console.log(count()));

count(1); // Effect runs immediately
count(2); // Effect runs immediately

// In batched contexts, you may need manual flushing
batch(() => {
  count(3); // Effect queued
  flush(); // Force effect execution
  count(4); // Effect queued again
}); // Both effects run after batch
```

---

## DOM Manipulation (@hellajs/dom)

The DOM package provides reactive rendering and JSX support.

### Mounting Applications

```typescript
import { signal } from '@hellajs/core';
import { mount } from '@hellajs/dom';

const App = () => {
  const count = signal(0);
  
  return (
    <div>
      <h1>Counter: {count}</h1>
      <button onClick={() => count(count() + 1)}>
        Increment
      </button>
    </div>
  );
};

mount(App, '#app');
```

### Reactive Properties

Properties can be reactive by using functions:

```typescript
const isVisible = signal(true);
const className = signal('primary');

const Component = () => (
  <div
    class={() => `button ${className()}`}
    style={() => ({ 
      display: isVisible() ? 'block' : 'none',
      color: isVisible() ? 'blue' : 'gray'
    })}
  >
    Dynamic content
  </div>
);
```

### List Rendering with forEach

Efficient list rendering with automatic diffing:

```typescript
import { signal } from '@hellajs/core';
import { forEach } from '@hellajs/dom';

const todos = signal([
  { id: 1, text: 'Learn HellaJS', done: false },
  { id: 2, text: 'Build app', done: false }
]);

const TodoList = () => (
  <ul>
    {forEach(todos, (todo) => (
      <li key={todo.id}>
        <input 
          type="checkbox" 
          checked={todo.done}
          onChange={(e) => {
            const newTodos = todos().map(t => 
              t.id === todo.id ? { ...t, done: e.target.checked } : t
            );
            todos(newTodos);
          }}
        />
        {todo.text}
      </li>
    ))}
  </ul>
);
```

### Event Handling

Events use global delegation for optimal performance:

```typescript
const Component = () => {
  const handleClick = (e: MouseEvent) => {
    console.log('Button clicked!', e.target);
  };
  
  const handleInput = (e: InputEvent) => {
    console.log('Input value:', e.target.value);
  };
  
  return (
    <div>
      <button onClick={handleClick}>Click me</button>
      <input onInput={handleInput} placeholder="Type here" />
      <form onSubmit={(e) => {
        e.preventDefault();
        console.log('Form submitted');
      }}>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
};
```

### Lifecycle Hooks

Components support lifecycle hooks for cleanup and updates:

```typescript
const Component = () => {
  const count = signal(0);
  
  return (
    <div
      onUpdate={() => console.log('Element updated')}
      onDestroy={() => console.log('Element destroyed')}
    >
      Count: {count}
      <button onClick={() => count(count() + 1)}>+</button>
    </div>
  );
};
```

### Fragments

Use fragments to avoid wrapper elements:

```typescript
import { Fragment } from '@hellajs/dom';

const MultipleElements = () => (
  <>
    <h1>Title</h1>
    <p>Description</p>
    <button>Action</button>
  </>
  // OR explicitly:
  // <Fragment>
  //   <h1>Title</h1>
  //   <p>Description</p>
  // </Fragment>
);
```

---

## CSS Styling (@hellajs/css)

The CSS package provides a powerful CSS-in-JS solution with automatic class generation.

### Basic CSS Generation

```typescript
import { css } from '@hellajs/css';

// Basic styles
const buttonClass = css({
  padding: '12px 24px',
  backgroundColor: '#007bff',
  color: 'white',
  border: 'none',
  borderRadius: '4px',
  cursor: 'pointer',
  '&:hover': {
    backgroundColor: '#0056b3'
  }
});

// Use in JSX
const Button = ({ children }) => (
  <button class={buttonClass}>
    {children}
  </button>
);
```

### Nested Selectors and Pseudo-classes

```typescript
const cardClass = css({
  padding: '16px',
  backgroundColor: 'white',
  borderRadius: '8px',
  boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
  
  '& .title': {
    fontSize: '18px',
    fontWeight: 'bold',
    marginBottom: '8px'
  },
  
  '& .content': {
    color: '#666',
    lineHeight: 1.5
  },
  
  '&:hover': {
    boxShadow: '0 4px 8px rgba(0,0,0,0.15)',
    transform: 'translateY(-2px)'
  },
  
  '@media (max-width: 768px)': {
    padding: '12px',
    '& .title': {
      fontSize: '16px'
    }
  }
});
```

### CSS Variables System

```typescript
import { cssVars, cssVarsReset } from '@hellajs/css';

// Define theme variables
const theme = cssVars({
  colors: {
    primary: '#007bff',
    secondary: '#6c757d',
    success: '#28a745',
    danger: '#dc3545'
  },
  spacing: {
    small: '8px',
    medium: '16px',
    large: '24px'
  },
  fonts: {
    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto',
    sizes: {
      small: '14px',
      medium: '16px',
      large: '20px'
    }
  }
});

// Use variables in styles
const primaryButtonClass = css({
  backgroundColor: theme.colors.primary, // becomes var(--colors-primary)
  padding: `${theme.spacing.medium} ${theme.spacing.large}`,
  fontSize: theme.fonts.sizes.medium,
  fontFamily: theme.fonts.family
});

// Reset variables
cssVarsReset(); // Clears all CSS variables
```

### Scoped Styles

```typescript
// Component-scoped styles
const componentClass = css({
  color: 'blue'
}, { scoped: 'my-component' });

// Results in .my-component .c1 { color: blue; }
// Use by adding 'my-component' class to parent element
```

### Global Styles

```typescript
// Global styles without class generation
css({
  body: {
    margin: 0,
    padding: 0,
    fontFamily: 'Arial, sans-serif'
  },
  '*': {
    boxSizing: 'border-box'
  }
}, { global: true });
```

### Style Management

```typescript
import { css, cssRemove, cssReset } from '@hellajs/css';

// Generate style and get class name
const dynamicClass = css({
  color: 'red'
});

// Remove specific style
cssRemove(dynamicClass);

// Reset all generated styles
cssReset();
```

---

## Data Fetching (@hellajs/resource)

The resource package provides powerful data fetching with caching, deduplication, and reactive integration.

### Basic Resource Usage

```typescript
import { resource } from '@hellajs/resource';

// Simple URL-based resource
const userResource = resource('/api/user/1');

// Fetch data
userResource.request();

// Access reactive state
console.log(userResource.loading()); // true initially
console.log(userResource.data());    // undefined initially
console.log(userResource.error());   // undefined initially
console.log(userResource.status());  // "loading"

// In components
const UserProfile = () => (
  <div>
    {userResource.loading() && <p>Loading...</p>}
    {userResource.error() && <p>Error: {userResource.error().message}</p>}
    {userResource.data() && (
      <div>
        <h2>{userResource.data().name}</h2>
        <p>{userResource.data().email}</p>
      </div>
    )}
  </div>
);
```

### Custom Fetchers

```typescript
import { signal } from '@hellajs/core';

const userId = signal(1);

const userResource = resource(
  async (id: number) => {
    const response = await fetch(`/api/users/${id}`);
    if (!response.ok) {
      throw new Error(`Failed to fetch user: ${response.status}`);
    }
    return response.json();
  },
  { 
    key: () => userId(),
    initialData: null
  }
);

// Automatic refetch when key changes
userId(2); // Triggers new request if auto: true
userResource.invalidate(); // Force refetch
```

### Resource Options

```typescript
const todosResource = resource(
  async (page: number) => {
    const response = await fetch(`/api/todos?page=${page}`);
    return response.json();
  },
  {
    key: () => currentPage(),
    initialData: [],
    cacheTime: 300000, // 5 minutes
    enabled: () => isLoggedIn(),
    auto: false, // Manual fetching only
    onSuccess: (data) => console.log('Todos loaded:', data),
    onError: (error) => console.error('Failed to load todos:', error)
  }
);
```

### Mutations

```typescript
const createTodoMutation = resource(
  async (todoData: { title: string; description: string }) => {
    const response = await fetch('/api/todos', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(todoData)
    });
    return response.json();
  },
  {
    onMutate: (variables) => {
      // Optimistic update
      const currentTodos = todosResource.data() || [];
      const optimisticTodo = { 
        id: Date.now(), 
        ...variables, 
        completed: false 
      };
      todosResource.setData([...currentTodos, optimisticTodo]);
      return { previousTodos: currentTodos };
    },
    onSuccess: (data, variables, context) => {
      // Refetch todos list
      todosResource.invalidate();
    },
    onError: (error, variables, context) => {
      // Rollback optimistic update
      if (context?.previousTodos) {
        todosResource.setData(context.previousTodos);
      }
    },
    onSettled: () => {
      console.log('Mutation completed');
    }
  }
);

// Execute mutation
createTodoMutation.mutate({ 
  title: 'New Todo', 
  description: 'Todo description' 
});
```

### Resource Cache Management

```typescript
import { resourceCache } from '@hellajs/resource';

// Cache operations
resourceCache.set('user-1', { id: 1, name: 'Alice' });
const cachedUser = resourceCache.get('user-1');

// Update cached data
resourceCache.update('user-1', (prevData) => ({
  ...prevData,
  lastAccessed: Date.now()
}));

// Invalidate cache entries
resourceCache.invalidate('user-1');
resourceCache.invalidateMultiple(['user-1', 'user-2']);

// Batch operations
resourceCache.updateMultiple({
  'user-1': (prev) => ({ ...prev, status: 'active' }),
  'user-2': (prev) => ({ ...prev, status: 'inactive' })
});

// Cache cleanup
resourceCache.cleanup(); // Remove expired entries
resourceCache.clear();   // Clear all entries
```

### Error Handling

```typescript
const apiResource = resource(
  async (endpoint: string) => {
    const response = await fetch(endpoint);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    return response.json();
  },
  {
    onError: (error) => {
      // Structured error information
      console.log('Error category:', error.category); // 'client', 'server', 'not_found', 'abort', 'unknown'
      console.log('Status code:', error.statusCode);  // HTTP status code
      console.log('Error message:', error.message);   // Human-readable message
      console.log('Original error:', error.originalError); // Full error object
    }
  }
);
```

---

## Client-side Routing (@hellajs/router)

The router package provides type-safe, reactive routing with parameter extraction and nested routes.

### Basic Router Setup

```typescript
import { router, route, navigate } from '@hellajs/router';

// Define routes
router({
  '/': () => <HomePage />,
  '/about': () => <AboutPage />,
  '/users/:id': (params) => <UserPage userId={params.id} />,
  '/products/:category/:id': (params) => (
    <ProductPage 
      category={params.category} 
      productId={params.id} 
    />
  )
}, {
  notFound: () => <NotFoundPage />
});

// Access current route
const currentRoute = route();
console.log(currentRoute.path);    // Current path
console.log(currentRoute.params);  // Route parameters
console.log(currentRoute.query);   // Query string object
```

### Navigation

```typescript
// Programmatic navigation
navigate('/users/123');
navigate('/products/electronics/456');

// With query parameters
navigate('/search', { 
  query: { q: 'hellajs', category: 'frameworks' }
});

// Replace current history entry
navigate('/dashboard', { replace: true });

// Navigation with parameters
const userId = signal(1);
navigate('/users/:id', { 
  params: { id: userId() }
});
```

### Route Parameters and Query Strings

```typescript
// Route with parameters
router({
  '/blog/:year/:month/:slug': (params, query) => {
    return (
      <BlogPost 
        year={parseInt(params.year)}
        month={parseInt(params.month)}
        slug={params.slug}
        preview={query.preview === 'true'}
        author={query.author}
      />
    );
  }
});

// Access route info reactively
const RouteInfo = () => {
  const currentRoute = route();
  
  return (
    <div>
      <p>Current path: {currentRoute.path}</p>
      <p>Parameters: {JSON.stringify(currentRoute.params)}</p>
      <p>Query: {JSON.stringify(currentRoute.query)}</p>
    </div>
  );
};
```

### Route Guards and Hooks

```typescript
router({
  '/admin/*': {
    before: () => {
      if (!isAuthenticated()) {
        navigate('/login');
        return false; // Prevent navigation
      }
      return true;
    },
    handler: () => <AdminPanel />
  },
  
  '/dashboard': {
    before: async () => {
      // Load user data before rendering
      const userData = await loadUserData();
      return { userData }; // Pass data to handler
    },
    handler: (params, query, context) => (
      <Dashboard user={context.userData} />
    ),
    after: (result) => {
      console.log('Dashboard rendered');
    }
  }
}, {
  // Global hooks
  before: () => {
    console.log('Navigation starting');
    // Analytics, loading states, etc.
  },
  after: () => {
    console.log('Navigation complete');
  }
});
```

### Nested Routes

```typescript
router({
  '/users': {
    handler: () => <UsersLayout />,
    children: {
      '/': () => <UsersList />,
      '/:id': (params) => <UserProfile userId={params.id} />,
      '/:id/edit': (params) => <EditUser userId={params.id} />,
      '/:id/posts': (params) => <UserPosts userId={params.id} />
    }
  },
  
  '/admin': {
    before: () => checkAdminAuth(),
    handler: () => <AdminLayout />,
    children: {
      '/': () => <AdminDashboard />,
      '/users': () => <AdminUsers />,
      '/settings': () => <AdminSettings />
    }
  }
});
```

### Redirects

```typescript
router({
  '/': () => <HomePage />,
  '/home': '/redirect/to/root', // Simple redirect
  '/old-path': {
    handler: () => {
      navigate('/new-path', { replace: true });
      return null;
    }
  }
}, {
  // Global redirects
  redirects: [
    ['/old-url', '/new-url'],
    ['/legacy/*', '/modern/$1'], // With wildcards
  ]
});
```

### Route-based Data Loading

```typescript
const userResource = resource(
  (userId: string) => fetch(`/api/users/${userId}`).then(r => r.json()),
  { key: () => route().params.id }
);

router({
  '/users/:id': (params) => {
    // Resource automatically refetches when route changes
    return (
      <div>
        {userResource.loading() && <LoadingSpinner />}
        {userResource.data() && (
          <UserProfile user={userResource.data()} />
        )}
      </div>
    );
  }
});
```

---

## State Management (@hellajs/store)

The store package provides reactive state management with nested object support and fine-grained updates.

### Creating Stores

```typescript
import { store } from '@hellajs/store';

// Basic store
const counterStore = store({
  count: 0,
  increment() {
    this.count++;
  },
  decrement() {
    this.count--;
  },
  reset() {
    this.count = 0;
  }
});

// Access properties reactively
const Counter = () => (
  <div>
    <p>Count: {counterStore.count()}</p>
    <button onClick={counterStore.increment}>+</button>
    <button onClick={counterStore.decrement}>-</button>
    <button onClick={counterStore.reset}>Reset</button>
  </div>
);
```

### Nested Store Structures

```typescript
const appStore = store({
  user: {
    id: null as number | null,
    name: '',
    email: '',
    preferences: {
      theme: 'light' as 'light' | 'dark',
      notifications: {
        email: true,
        push: false,
        sms: false
      }
    }
  },
  ui: {
    sidebarOpen: false,
    currentPage: 'home' as string,
    loading: false
  },
  todos: [] as Array<{
    id: number;
    text: string;
    completed: boolean;
    createdAt: Date;
  }>
});

// Fine-grained reactive updates
const UserProfile = () => (
  <div>
    {/* Only updates when user.name changes */}
    <h1>{appStore.user.name()}</h1>
    
    {/* Only updates when user.email changes */}
    <p>{appStore.user.email()}</p>
    
    {/* Only updates when theme preference changes */}
    <div className={`theme-${appStore.user.preferences.theme()}`}>
      <ToggleTheme />
    </div>
  </div>
);

// Updating nested properties
const updateTheme = (newTheme: 'light' | 'dark') => {
  appStore.user.preferences.theme(newTheme);
};

const toggleNotification = (type: 'email' | 'push' | 'sms') => {
  const notifications = appStore.user.preferences.notifications;
  notifications[type](!notifications[type]());
};
```

### Bulk Store Updates

```typescript
// Complete state replacement
appStore.set({
  user: {
    id: 1,
    name: 'Alice Johnson',
    email: 'alice@example.com',
    preferences: {
      theme: 'dark',
      notifications: {
        email: true,
        push: true,
        sms: false
      }
    }
  },
  ui: {
    sidebarOpen: true,
    currentPage: 'dashboard',
    loading: false
  },
  todos: []
});

// Partial deep updates
appStore.update({
  user: {
    name: 'Alice Smith', // Updates name, preserves other user properties
    preferences: {
      theme: 'light' // Updates theme, preserves other preferences
    }
  },
  ui: {
    loading: true // Updates loading, preserves other UI properties
  }
  // todos array remains unchanged
});
```

### Store Computed Values

```typescript
const todoStore = store({
  items: [] as Todo[],
  filter: 'all' as 'all' | 'active' | 'completed'
});

// Computed values based on store state
const filteredTodos = computed(() => {
  const items = todoStore.items();
  const filter = todoStore.filter();
  
  switch (filter) {
    case 'active':
      return items.filter(todo => !todo.completed);
    case 'completed':
      return items.filter(todo => todo.completed);
    default:
      return items;
  }
});

const todoStats = computed(() => {
  const items = todoStore.items();
  return {
    total: items.length,
    active: items.filter(t => !t.completed).length,
    completed: items.filter(t => t.completed).length
  };
});

// Use in components
const TodoApp = () => (
  <div>
    <TodoStats stats={todoStats()} />
    <TodoList todos={filteredTodos()} />
  </div>
);
```

### Readonly Stores

```typescript
// Selective readonly properties
const configStore = store({
  appName: 'MyApp',
  version: '1.0.0',
  user: {
    id: 1,
    name: 'Alice'
  },
  settings: {
    theme: 'light',
    language: 'en'
  }
}, {
  readonly: ['appName', 'version'] // Only these properties are readonly
});

// Completely readonly store
const constantsStore = store({
  API_URL: 'https://api.example.com',
  MAX_RETRIES: 3,
  TIMEOUT: 5000
}, {
  readonly: true // All properties are readonly
});

// TypeScript prevents mutations on readonly properties
// configStore.appName('NewName'); // L TypeScript error
// configStore.user.name('Bob');   //  Allowed

// Runtime errors for readonly violations
try {
  configStore.appName('NewName'); // Throws error at runtime
} catch (error) {
  console.error('Cannot modify readonly property');
}
```

### Store Integration Patterns

```typescript
// Store with effects for persistence
const persistentStore = store({
  theme: 'light' as 'light' | 'dark',
  language: 'en',
  preferences: {
    autoSave: true,
    notifications: true
  }
});

// Auto-save to localStorage
effect(() => {
  const state = persistentStore(); // Get reactive snapshot
  localStorage.setItem('app-preferences', JSON.stringify(state));
});

// Load from localStorage on init
const savedPrefs = localStorage.getItem('app-preferences');
if (savedPrefs) {
  persistentStore.set(JSON.parse(savedPrefs));
}

// Store with validation
const userFormStore = store({
  firstName: '',
  lastName: '',
  email: '',
  age: 0
});

const formValidation = computed(() => {
  const { firstName, lastName, email, age } = userFormStore();
  const errors: string[] = [];
  
  if (!firstName()) errors.push('First name is required');
  if (!lastName()) errors.push('Last name is required');
  if (!email() || !email().includes('@')) errors.push('Valid email is required');
  if (age() < 18) errors.push('Must be 18 or older');
  
  return {
    isValid: errors.length === 0,
    errors
  };
});
```

### Store Disposal and Cleanup

```typescript
// Store with cleanup capabilities
const resourceStore = store({
  connections: [] as WebSocket[],
  timers: [] as NodeJS.Timeout[]
});

// Custom cleanup method
resourceStore.dispose = () => {
  // Close WebSocket connections
  resourceStore.connections().forEach(ws => ws.close());
  
  // Clear timers
  resourceStore.timers().forEach(timer => clearTimeout(timer));
  
  // Reset store state
  resourceStore.set({
    connections: [],
    timers: []
  });
};

// Use in component cleanup
const Component = () => {
  // ... component logic
  
  return (
    <div onDestroy={() => resourceStore.dispose()}>
      {/* Component content */}
    </div>
  );
};
```

---

## Integration Patterns

### Component Composition

```typescript
// Higher-order components with stores
const withAuth = (Component: () => JSX.Element) => {
  return () => {
    const authStore = useAuth();
    
    if (!authStore.isAuthenticated()) {
      return <LoginForm />;
    }
    
    return <Component />;
  };
};

// Provider pattern
const AppProvider = ({ children }) => {
  const appStore = store({
    user: null,
    theme: 'light',
    notifications: []
  });
  
  // Make store available to children
  provide('appStore', appStore);
  
  return (
    <div className={`theme-${appStore.theme()}`}>
      {children}
    </div>
  );
};

// Consumer components
const UserProfile = () => {
  const appStore = inject('appStore');
  
  return (
    <div>
      <h1>Welcome, {appStore.user().name}</h1>
    </div>
  );
};
```

### Form Handling

```typescript
const ContactForm = () => {
  const formStore = store({
    firstName: '',
    lastName: '',
    email: '',
    message: '',
    isSubmitting: false
  });
  
  const validation = computed(() => {
    const { firstName, lastName, email, message } = formStore();
    
    return {
      firstName: firstName() ? null : 'First name required',
      lastName: lastName() ? null : 'Last name required',
      email: email().includes('@') ? null : 'Valid email required',
      message: message().length >= 10 ? null : 'Message must be at least 10 characters',
      isValid: firstName() && lastName() && email().includes('@') && message().length >= 10
    };
  });
  
  const submitForm = async () => {
    if (!validation().isValid) return;
    
    formStore.isSubmitting(true);
    
    try {
      await fetch('/api/contact', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          firstName: formStore.firstName(),
          lastName: formStore.lastName(),
          email: formStore.email(),
          message: formStore.message()
        })
      });
      
      // Reset form on success
      formStore.update({
        firstName: '',
        lastName: '',
        email: '',
        message: ''
      });
      
      alert('Message sent successfully!');
    } catch (error) {
      console.error('Failed to send message:', error);
    } finally {
      formStore.isSubmitting(false);
    }
  };
  
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      submitForm();
    }}>
      <div>
        <input
          type="text"
          placeholder="First Name"
          value={formStore.firstName()}
          onInput={(e) => formStore.firstName(e.target.value)}
          class={() => validation().firstName ? 'error' : ''}
        />
        {validation().firstName && <span class="error">{validation().firstName}</span>}
      </div>
      
      <div>
        <input
          type="text"
          placeholder="Last Name"
          value={formStore.lastName()}
          onInput={(e) => formStore.lastName(e.target.value)}
          class={() => validation().lastName ? 'error' : ''}
        />
        {validation().lastName && <span class="error">{validation().lastName}</span>}
      </div>
      
      <div>
        <input
          type="email"
          placeholder="Email"
          value={formStore.email()}
          onInput={(e) => formStore.email(e.target.value)}
          class={() => validation().email ? 'error' : ''}
        />
        {validation().email && <span class="error">{validation().email}</span>}
      </div>
      
      <div>
        <textarea
          placeholder="Your message"
          value={formStore.message()}
          onInput={(e) => formStore.message(e.target.value)}
          class={() => validation().message ? 'error' : ''}
        />
        {validation().message && <span class="error">{validation().message}</span>}
      </div>
      
      <button 
        type="submit" 
        disabled={() => !validation().isValid || formStore.isSubmitting()}
      >
        {formStore.isSubmitting() ? 'Sending...' : 'Send Message'}
      </button>
    </form>
  );
};
```

### Real-time Data with WebSockets

```typescript
const useWebSocket = (url: string) => {
  const connectionStore = store({
    ws: null as WebSocket | null,
    connected: false,
    error: null as string | null,
    lastMessage: null as any
  });
  
  const connect = () => {
    const ws = new WebSocket(url);
    
    ws.onopen = () => {
      connectionStore.update({
        ws,
        connected: true,
        error: null
      });
    };
    
    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      connectionStore.lastMessage(message);
    };
    
    ws.onerror = () => {
      connectionStore.update({
        connected: false,
        error: 'WebSocket connection failed'
      });
    };
    
    ws.onclose = () => {
      connectionStore.update({
        connected: false,
        ws: null
      });
    };
  };
  
  const disconnect = () => {
    const ws = connectionStore.ws();
    if (ws) {
      ws.close();
      connectionStore.update({
        ws: null,
        connected: false
      });
    }
  };
  
  const send = (message: any) => {
    const ws = connectionStore.ws();
    if (ws && connectionStore.connected()) {
      ws.send(JSON.stringify(message));
    }
  };
  
  return {
    ...connectionStore,
    connect,
    disconnect,
    send
  };
};

// Usage in components
const ChatApp = () => {
  const ws = useWebSocket('wss://api.example.com/chat');
  const messages = signal([]);
  const messageInput = signal('');
  
  // Connect on mount
  effect(() => {
    ws.connect();
    return () => ws.disconnect();
  });
  
  // Handle incoming messages
  effect(() => {
    const lastMessage = ws.lastMessage();
    if (lastMessage) {
      messages([...messages(), lastMessage]);
    }
  });
  
  const sendMessage = () => {
    const text = messageInput();
    if (text.trim()) {
      ws.send({ type: 'message', text });
      messageInput('');
    }
  };
  
  return (
    <div>
      <div class="status">
        {ws.connected() ? '=â Connected' : '=4 Disconnected'}
        {ws.error() && <span class="error">{ws.error()}</span>}
      </div>
      
      <div class="messages">
        {forEach(messages, (msg) => (
          <div key={msg.id} class="message">
            <strong>{msg.author}:</strong> {msg.text}
          </div>
        ))}
      </div>
      
      <div class="input">
        <input
          value={messageInput()}
          onInput={(e) => messageInput(e.target.value)}
          onKeyPress={(e) => {
            if (e.key === 'Enter') sendMessage();
          }}
          placeholder="Type a message..."
        />
        <button onClick={sendMessage}>Send</button>
      </div>
    </div>
  );
};
```

---

## TypeScript Integration

### Type Safety with Generics

```typescript
// Strongly typed resources
interface User {
  id: number;
  name: string;
  email: string;
}

interface Post {
  id: number;
  title: string;
  content: string;
  authorId: number;
}

const userResource = resource<User>('/api/user/1');
const postsResource = resource<Post[]>('/api/posts');

// TypeScript infers return types
const userData = userResource.data(); // User | undefined
const posts = postsResource.data();   // Post[] | undefined
```

### Store Type Inference

```typescript
interface AppState {
  user: {
    id: number;
    name: string;
    preferences: {
      theme: 'light' | 'dark';
      notifications: boolean;
    };
  } | null;
  todos: Array<{
    id: number;
    text: string;
    completed: boolean;
  }>;
}

const typedStore = store<AppState>({
  user: null,
  todos: []
});

// TypeScript enforces correct types
typedStore.user({ 
  id: 1, 
  name: 'Alice',
  preferences: { theme: 'light', notifications: true }
}); //  Correct

// typedStore.user({ invalidProp: true }); // L TypeScript error
```

### Router Type Safety

```typescript
// Type-safe route parameters
interface RouteParams {
  userId: string;
  postId: string;
}

router<RouteParams>({
  '/users/:userId/posts/:postId': (params) => {
    // params is strongly typed as RouteParams
    const userId = parseInt(params.userId);
    const postId = parseInt(params.postId);
    
    return <PostDetail userId={userId} postId={postId} />;
  }
});

// Strongly typed navigation
navigate<RouteParams>('/users/:userId/posts/:postId', {
  params: { 
    userId: '123', 
    postId: '456' 
  }
});
```

### Component Props Types

```typescript
interface ButtonProps {
  variant: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  onClick?: (event: MouseEvent) => void;
  children: JSX.Element | string;
}

const Button = (props: ButtonProps) => {
  const classes = css({
    padding: props.size === 'small' ? '8px 16px' : '12px 24px',
    fontSize: props.size === 'small' ? '14px' : '16px',
    backgroundColor: {
      primary: '#007bff',
      secondary: '#6c757d',
      danger: '#dc3545'
    }[props.variant],
    opacity: props.disabled ? 0.6 : 1,
    cursor: props.disabled ? 'not-allowed' : 'pointer'
  });
  
  return (
    <button 
      class={classes}
      disabled={props.disabled}
      onClick={props.onClick}
    >
      {props.children}
    </button>
  );
};

// Usage with type checking
const App = () => (
  <div>
    <Button variant="primary" size="large">
      Primary Button
    </Button>
    
    {/* TypeScript error - invalid variant */}
    {/* <Button variant="invalid">Error</Button> */}
  </div>
);
```

### Advanced Type Patterns

```typescript
// Conditional types for resources
type ResourceState<T> = {
  data: T | undefined;
  loading: boolean;
  error: ResourceError | undefined;
  status: 'idle' | 'loading' | 'success' | 'error';
};

// Utility type for extracting store properties
type StoreValue<T> = T extends (...args: any[]) => infer R ? R : T;

// Helper for creating typed stores
function createTypedStore<T extends Record<string, any>>(
  initialState: T
): {
  [K in keyof T]: T[K] extends (...args: any[]) => any
    ? T[K]
    : Signal<T[K]>;
} {
  return store(initialState);
}

// Usage
const appStore = createTypedStore({
  count: 0,
  increment() { this.count++; },
  user: { name: 'Alice', age: 30 }
});

// Type-safe access
const count = appStore.count(); // number
const user = appStore.user();   // { name: string; age: number }
appStore.increment();           // Method call
```

---

## Performance Optimizations

### Signal Performance Patterns

```typescript
// Prefer fine-grained signals over large objects
// L Less efficient - entire object tracked
const userSignal = signal({
  name: 'Alice',
  email: 'alice@example.com',
  preferences: { theme: 'light' }
});

//  More efficient - fine-grained tracking
const userName = signal('Alice');
const userEmail = signal('alice@example.com');
const userTheme = signal('light');

// Or use stores for structured data
const userStore = store({
  name: 'Alice',
  email: 'alice@example.com',
  preferences: {
    theme: 'light'
  }
});
```

### Computed Value Optimization

```typescript
// Expensive computation with memoization
const expensiveComputation = computed(() => {
  const data = largeDataSignal();
  
  // Complex processing only runs when data changes
  return data
    .filter(item => item.active)
    .map(item => ({
      ...item,
      computed: heavyCalculation(item)
    }))
    .sort((a, b) => a.priority - b.priority);
});

// Conditional computations to minimize dependencies
const conditionalValue = computed(() => {
  const mode = modeSignal();
  
  if (mode === 'simple') {
    return simpleDataSignal(); // Only depends on simpleDataSignal
  } else {
    return complexDataSignal(); // Only depends on complexDataSignal when needed
  }
});
```

### Batch Updates for Performance

```typescript
// Batch multiple signal updates
const updateUserProfile = (userData) => {
  batch(() => {
    userStore.name(userData.name);
    userStore.email(userData.email);
    userStore.preferences.theme(userData.theme);
    userStore.preferences.notifications(userData.notifications);
    // All updates happen in one reactive cycle
  });
};

// Avoid individual updates that cause multiple re-renders
const inefficientUpdate = (userData) => {
  userStore.name(userData.name);        // Triggers effects
  userStore.email(userData.email);     // Triggers effects again
  userStore.preferences.theme(userData.theme); // Triggers effects again
};
```

### List Rendering Performance

```typescript
// Use stable keys for optimal forEach performance
const TodoList = () => {
  const todos = signal([
    { id: 1, text: 'Task 1', completed: false },
    { id: 2, text: 'Task 2', completed: true }
  ]);
  
  return (
    <ul>
      {forEach(todos, (todo) => (
        <li key={todo.id}> {/* Stable key enables efficient diffing */}
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={(e) => {
              const newTodos = todos().map(t =>
                t.id === todo.id 
                  ? { ...t, completed: e.target.checked }
                  : t
              );
              todos(newTodos);
            }}
          />
          {todo.text}
        </li>
      ))}
    </ul>
  );
};

// Avoid index-based keys for dynamic lists
// L Causes unnecessary re-renders on reordering
{forEach(items, (item, index) => (
  <Item key={index} data={item} />
))}

//  Use stable, unique identifiers
{forEach(items, (item) => (
  <Item key={item.id} data={item} />
))}
```

### Resource Caching Strategies

```typescript
// Configure appropriate cache times
const userResource = resource('/api/user', {
  cacheTime: 300000, // 5 minutes for user data
});

const constantsResource = resource('/api/constants', {
  cacheTime: 3600000, // 1 hour for rarely changing data
});

const realtimeResource = resource('/api/realtime-data', {
  cacheTime: 0, // No caching for real-time data
});

// Use resource deduplication for shared data
const createUserResource = (userId: number) =>
  resource(`/api/users/${userId}`, {
    key: () => userId, // Shared cache key enables deduplication
  });

// Multiple components can share the same resource
const user1Resource = createUserResource(1);
const user1ResourceAgain = createUserResource(1); // Shares cache and requests
```

### CSS Performance

```typescript
// Minimize style recalculation
const staticStyles = css({
  display: 'flex',
  alignItems: 'center',
  padding: '16px'
}); // Generated once

const DynamicComponent = () => {
  const isActive = signal(false);
  
  // L Recreates styles on every render
  const inefficientClass = () => css({
    color: isActive() ? 'blue' : 'gray'
  });
  
  //  Use conditional classes instead
  const activeClass = css({ color: 'blue' });
  const inactiveClass = css({ color: 'gray' });
  
  return (
    <div 
      class={`${staticStyles} ${isActive() ? activeClass : inactiveClass}`}
    >
      Content
    </div>
  );
};
```

### Memory Management

```typescript
// Clean up resources and effects
const ComponentWithCleanup = () => {
  const timer = signal<NodeJS.Timeout | null>(null);
  const subscription = signal<() => void | null>(null);
  
  // Setup
  effect(() => {
    const intervalId = setInterval(() => {
      console.log('Timer tick');
    }, 1000);
    timer(intervalId);
    
    const unsub = someEventSource.subscribe(data => {
      console.log('Data received:', data);
    });
    subscription(unsub);
    
    // Cleanup when component unmounts
    return () => {
      clearInterval(intervalId);
      unsub();
    };
  });
  
  return (
    <div onDestroy={() => {
      // Additional cleanup if needed
      const timerId = timer();
      if (timerId) clearInterval(timerId);
      
      const unsub = subscription();
      if (unsub) unsub();
    }}>
      Component content
    </div>
  );
};
```

---

## Build Integration

### Vite Plugin

```javascript
// vite.config.js
import { defineConfig } from 'vite';
import viteHellaJS from 'vite-plugin-hellajs';

export default defineConfig({
  plugins: [viteHellaJS()],
  // TypeScript configuration
  esbuild: {
    jsx: 'preserve'
  }
});
```

```json
// tsconfig.json
{
  "compilerOptions": {
    "jsx": "preserve",
    "types": ["@hellajs/dom"]
  }
}
```

### Rollup Plugin

```javascript
// rollup.config.js
import hellaJSPlugin from '@hellajs/rollup-plugin';

export default {
  plugins: [
    hellaJSPlugin()
  ]
};
```

### Babel Plugin

```json
// .babelrc
{
  "plugins": ["@hellajs/babel-plugin"]
}
```

### Package.json Dependencies

```json
{
  "dependencies": {
    "@hellajs/core": "^1.0.0",
    "@hellajs/dom": "^1.0.0",
    "@hellajs/css": "^1.0.0",
    "@hellajs/resource": "^1.0.0",
    "@hellajs/router": "^1.0.0",
    "@hellajs/store": "^1.0.0"
  },
  "devDependencies": {
    "vite-plugin-hellajs": "^1.0.0",
    "typescript": "^5.0.0"
  }
}
```

---

## Testing Patterns

### Component Testing

```typescript
import { test, expect } from 'bun:test';
import { signal, effect } from '@hellajs/core';
import { mount } from '@hellajs/dom';

test('counter component', async () => {
  const Counter = () => {
    const count = signal(0);
    
    return (
      <div>
        <span data-testid="count">{count}</span>
        <button 
          data-testid="increment"
          onClick={() => count(count() + 1)}
        >
          +
        </button>
      </div>
    );
  };
  
  // Mount component in test DOM
  const container = document.createElement('div');
  document.body.appendChild(container);
  
  mount(Counter, container);
  
  // Test initial state
  const countElement = container.querySelector('[data-testid="count"]');
  const incrementButton = container.querySelector('[data-testid="increment"]');
  
  expect(countElement?.textContent).toBe('0');
  
  // Test interaction
  incrementButton?.click();
  await new Promise(resolve => setTimeout(resolve, 0)); // Wait for effects
  
  expect(countElement?.textContent).toBe('1');
  
  // Cleanup
  document.body.removeChild(container);
});
```

### Store Testing

```typescript
import { test, expect } from 'bun:test';
import { store } from '@hellajs/store';

test('user store updates', () => {
  const userStore = store({
    name: '',
    email: '',
    preferences: {
      theme: 'light' as 'light' | 'dark'
    }
  });
  
  // Test initial state
  expect(userStore.name()).toBe('');
  expect(userStore.preferences.theme()).toBe('light');
  
  // Test property updates
  userStore.name('Alice');
  expect(userStore.name()).toBe('Alice');
  
  // Test nested updates
  userStore.preferences.theme('dark');
  expect(userStore.preferences.theme()).toBe('dark');
  
  // Test bulk updates
  userStore.update({
    name: 'Bob',
    email: 'bob@example.com'
  });
  
  expect(userStore.name()).toBe('Bob');
  expect(userStore.email()).toBe('bob@example.com');
  expect(userStore.preferences.theme()).toBe('dark'); // Preserved
});
```

### Resource Testing

```typescript
import { test, expect } from 'bun:test';
import { resource } from '@hellajs/resource';

test('resource data fetching', async () => {
  const mockData = { id: 1, name: 'Test User' };
  
  // Mock fetch
  global.fetch = async (url) => ({
    ok: true,
    json: async () => mockData
  }) as Response;
  
  const userResource = resource('/api/user/1');
  
  // Test initial state
  expect(userResource.status()).toBe('idle');
  expect(userResource.loading()).toBe(false);
  expect(userResource.data()).toBeUndefined();
  
  // Trigger fetch
  userResource.request();
  
  expect(userResource.status()).toBe('loading');
  expect(userResource.loading()).toBe(true);
  
  // Wait for completion
  await new Promise(resolve => {
    const checkStatus = () => {
      if (userResource.status() !== 'loading') {
        resolve(undefined);
      } else {
        setTimeout(checkStatus, 10);
      }
    };
    checkStatus();
  });
  
  expect(userResource.status()).toBe('success');
  expect(userResource.loading()).toBe(false);
  expect(userResource.data()).toEqual(mockData);
});
```

---

## Advanced Patterns & Best Practices

### Error Boundaries

```typescript
const ErrorBoundary = ({ children, fallback }) => {
  const error = signal<Error | null>(null);
  
  const resetError = () => error(null);
  
  // Catch errors in child components
  effect(() => {
    const handleError = (event: ErrorEvent) => {
      error(event.error);
      event.preventDefault();
    };
    
    window.addEventListener('error', handleError);
    return () => window.removeEventListener('error', handleError);
  });
  
  if (error()) {
    return (
      <div class="error-boundary">
        <h2>Something went wrong</h2>
        <details>
          <summary>Error details</summary>
          <pre>{error()?.stack}</pre>
        </details>
        <button onClick={resetError}>Try again</button>
        {fallback?.(error())}
      </div>
    );
  }
  
  return children;
};

// Usage
const App = () => (
  <ErrorBoundary fallback={(error) => <CustomErrorDisplay error={error} />}>
    <MainContent />
  </ErrorBoundary>
);
```

### Lazy Loading Components

```typescript
const LazyComponent = (importFn: () => Promise<{ default: () => JSX.Element }>) => {
  const component = signal<(() => JSX.Element) | null>(null);
  const loading = signal(true);
  const error = signal<Error | null>(null);
  
  // Load component on first render
  effect(() => {
    importFn()
      .then(module => {
        component(module.default);
        loading(false);
      })
      .catch(err => {
        error(err);
        loading(false);
      });
  });
  
  return () => {
    if (loading()) {
      return <div class="loading">Loading component...</div>;
    }
    
    if (error()) {
      return <div class="error">Failed to load component: {error()?.message}</div>;
    }
    
    const Component = component();
    return Component ? <Component /> : null;
  };
};

// Usage
const LazyDashboard = LazyComponent(() => import('./Dashboard'));

const App = () => (
  <div>
    <header>My App</header>
    <main>
      <LazyDashboard />
    </main>
  </div>
);
```

### Middleware Pattern for Stores

```typescript
type StoreMiddleware<T> = (
  store: T,
  action: string,
  payload: any
) => void;

const loggingMiddleware: StoreMiddleware<any> = (store, action, payload) => {
  console.log(`Store action: ${action}`, payload);
};

const persistenceMiddleware: StoreMiddleware<any> = (store, action, payload) => {
  if (action.startsWith('set') || action.startsWith('update')) {
    localStorage.setItem('app-state', JSON.stringify(store()));
  }
};

const createMiddlewareStore = <T extends Record<string, any>>(
  initialState: T,
  middlewares: StoreMiddleware<any>[] = []
) => {
  const baseStore = store(initialState);
  
  // Wrap store methods to trigger middleware
  const proxy = new Proxy(baseStore, {
    get(target, prop) {
      const value = target[prop as keyof typeof target];
      
      if (typeof value === 'function' && typeof prop === 'string') {
        return (...args: any[]) => {
          // Trigger middleware before action
          middlewares.forEach(middleware => {
            middleware(baseStore, prop, args);
          });
          
          return value.apply(target, args);
        };
      }
      
      return value;
    }
  });
  
  return proxy;
};

// Usage
const appStore = createMiddlewareStore(
  {
    user: null,
    posts: []
  },
  [loggingMiddleware, persistenceMiddleware]
);
```

### Context and Dependency Injection

```typescript
// Simple context system
const contexts = new Map<string, any>();

const provide = <T>(key: string, value: T): void => {
  contexts.set(key, value);
};

const inject = <T>(key: string): T => {
  const value = contexts.get(key);
  if (value === undefined) {
    throw new Error(`Context "${key}" not found`);
  }
  return value;
};

// Theme provider example
const ThemeProvider = ({ children }) => {
  const themeStore = store({
    primaryColor: '#007bff',
    secondaryColor: '#6c757d',
    mode: 'light' as 'light' | 'dark'
  });
  
  provide('theme', themeStore);
  
  const cssVarsObj = cssVars({
    primary: themeStore.primaryColor(),
    secondary: themeStore.secondaryColor(),
    background: themeStore.mode() === 'light' ? '#ffffff' : '#1a1a1a',
    text: themeStore.mode() === 'light' ? '#333333' : '#ffffff'
  });
  
  return (
    <div class={`theme-${themeStore.mode()}`}>
      {children}
    </div>
  );
};

// Component using theme
const ThemedButton = ({ children }) => {
  const theme = inject<ReturnType<typeof store>>('theme');
  
  const buttonClass = css({
    backgroundColor: theme.primaryColor(),
    color: 'white',
    padding: '12px 24px',
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer'
  });
  
  return (
    <button class={buttonClass}>
      {children}
    </button>
  );
};
```

This comprehensive llms.txt serves as the definitive guide for MCP servers working with HellaJS applications. It covers all aspects from basic concepts to advanced patterns, providing practical examples and best practices for building reactive applications with the HellaJS framework.